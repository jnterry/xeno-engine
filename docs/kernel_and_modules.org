* Overview

	Xeno Engine is split into various smaller libraries, each of which has its own folder within the =/source= folder.

	Folders without a "module-" prefix are "normal" libraries that can be linked into any application that wishes to make use of the corresponding functionality.

	Games/multimedia applications are expected to use the =kernel= llibrary. This library is capable of loading the libraries prefixed with "module-" at runtime in order to provide some extra functionality to the engine.

	This allows the kernel to provide various support functions to the loaded modules:
	- Concept of a "tick", which usually corresponds to a frame in the application, with context such as delta time since last tick, etc
	- Submission of asynchronous tasks to be completed by the end of the tick (or some earlier user defined point such that dependencies between tasks can be expressed)
	- Dynamic reloading of modules when source code changes (yes, this is hot reloadable c++ code!)
	- Centralised logging
	- Memory allocations (in a debug-able way)

* Building an Application

	Unfortuantelly the way in which in application is built varies slightly depending on the platform.

	The general idea is we have some central executable which is light, doing pretty much nothing but:
	- Call =xen::initKernel()=
	- Load required modules (maybe reading a config file to determine which to load, eg, OpenGL or DirectX module for graphics)
	- Call =xen::startKernel()=
	The intended design is that game logic is put in one of the loaded modules.

	Under unix code in shared libraries may call functions linked into the executable, however this is not the case on windows.
	Hence under unix it is preferable for the central executable to link against common code such as =xen-math= and =xen-core= - this approach ensures code is not duplicated into each shared module. It is possible for each module to link individually, bit probally not desired.
	Under windows we do not have this option, and instead each module must link its dependencies itself.

	The exception to this rule is that it is the individual modules *DO NOT* link against the =xen-kernel= library on, *THIS APPLIED TO ALL SYSTEMS* - instead only the central executable should link against =xen-kernel=. Failure to adhear to this will cause global kernel state to be duplicated in each module, causing strange errors (usually segfaults during module init).
	Instead modules should use the macro =XenDelcareModule= to ensure they export the correct symbols on each platform, this will also magically ensure any syscalls made from the modules to the kernel use the function linked into the executable. This "magic" is not done for any other modules since it is a pain to maintain (see =Module.win.hpp=).

* Ticks

	The kernel runs in a loop where each iteration of the loop is a "tick". In most applications this will correspond to a single frame.

	Each module that has been loaded can perform some processing during the tick, as the kernel will call the modules =.tick()= function.

	This tick function may kick of background work by submitting jobs the kernel that must be completed before the end of the tick.

* Threading Model

	The kernel has a single master thread (this is the thread which calls =xen::initKernel()= and then =xen::startKernel()=), and some configurable number of worker threads, spawned when the kernel is initialised.

	The master thread will ALWAYS be used to call any module init(), load() and tick() functions. This guarantee ensures that any resources that can only be used by a single thread (eg, an OpenGL context) may be safely created within the module's =init()= function and the used in the =tick()= function.

** Tick Work

	 Tick work are small pieces of work which must be completed before the end of the tick. It is expected that the =tick()= function of modules will offload any parallizable work to the kernel's worker threads by calling =xen::pushTickWork()=.

	 Any memory that is accessed by such work entries must therefore remain valid until the end of the tick, unless the work is forced to be completed earlier by the master thread calling ~xen::waitForTickWork()~.

	 Note that it is also possible for work entries to submit more work, or to call ~waitForTickWork~ in order express dependencies between work entries. The thread calling ~waitForTickWork~ will contribute towards completing the task in question.
