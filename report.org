* Introduction

	We have implemented all that was requested for the 50% for both the raytracer and rasterizer. The rest of this document explains how we have expanded on this initial task.

	We have implemented this coursework as if it were the beginings of a full graphics engine (which we have named "Xeno Engine"). That is, the rendering portion is implemented as a (set of) shared libraries which applications link against. Additionally there are many helper utility functions and classes not directly related to graphics, such as memory management, file loading, etc.

	Additionally we have structured the engine such that a single interface is exposed to client applications while multiple "rendering backends" can be used. We have implemented a software rasterizer, software Raytracer and a proof of concept OpenGL backend using this interface. The OpenGL implementation is not designed to be feature complete, but is to show the interface can also be used as a wrapper around traditional rendering APIs, and we found it useful in our testing to ensure our own rendering achieved visually similar results.

* Code Structure

	This approach has lead our code base to be substantially larger than may have been expected for this coursework; an outline of the structure of the code is given below:

	- =source/xen= - Contains source code for the engine
		- =core= - Core utility functions and types not directly related to graphics, eg, memory managment
		- =math= - Implementation of mathematical helper functions and types. *Note that we do not rely on glm, but have implemented our own maths from scratch*
		- =graphics= - Definition of the shared graphics interface as well as various helper functions and types (eg, for dealing with colors or images) which do not rely on a particular rendering backend
		- =sren= - Stands for "software renderer". Contains implementation of both the software rasterizer and software Raytracer backends
		- =gl= - Contains a basic OpenGL implementation of the rendering backend
	- =examples= - Source code for various example applications. These are the "mains" and link against the shared xeno-engine libraries
	- =tests= - Source code for automated unit tests

	As well as the source code the repository also contains:
	- =tools= - Various helper scripts and utilities
	- =lib=   - Output directory for shared libraries generated by the build system
	- =bin=   - Output directory for executables generated by the build system. Also contains any resource files needed by these executables at runtime.

* Build System

	We have used CMake to manage the build process for this project.

	The entire engine and all examples may be built by:

	1. Creating a directory "build" in the root of the repository
	2. Running the command ~cmake ..~ from the build directory
	3. Running the command ~make~ in the build directory
	4. Running the example executables which will have been placed in bin

* Extensions

	Due to the way we have structured this coursework some extensions apply to all rendering backend, and others apply only to specific backends. Below we outline those that apply to each specifically, as well as those extensions which are shared between all rendering backends.

** Raytracer

   - :TODO: Efficient search structure for finding intersections in geometry

** Rasterizer

	 - Multiple primitive types
		 - Software rasterizer supports multiple primitive types (definitions taken from opengl, but implemented in software)
		 - We support: TRIANGLES, LINES, LINE_STRIP, POINTS
		 - Note that the Raytracer backend will fall back to using the rasterizer for all primative types except TRIANGLES
	 - Full clipping pipeline
		 - All primitive types are clipped by the engine such that the camera can be moved without segfaults, all geometry not in view is not drawn
		 - Geometry partially on and partially off of the screen is clipped to the viewport

** Shared

	 - Per Vertex Colors
		 - Both the software rasterizer and software raytracer support per vertex colors, rather than just per triangle colors. These colors are blended together
	 - Mesh Loader
		 - :TODO: flexible mesh system which can represent meshes with arbitrary number of attributes, each of an arbitrary type
		 - Using assimp library to load mesh formats such as obj
	 - Windowing System
		 - Low level implementation of window management, event polling etc using raw operating system calls with no reliance on external libraries
		 - Implementation for both X11 and windows
		 - SIMD optimization for transforming floating framebuffer to byte pixels to display
		 - :TODO: add SDL implementation and benchmark
	 - Post Processing Pipeline
		 - The software rendering backends support applying "post-processing" steps after the image has been rendered
		 - :TODO: what post processors have we actually implemented?
