* Introduction

	We have implemented all that was requested for the 50% for both the raytracer and rasterizer. The rest of this document explains how we have expanded on this initial task.

	We have implemented this coursework as if it were the beginings of a full graphics engine (which we have named "Xeno Engine"). That is, the rendering portion is implemented as a (set of) shared libraries which applications link against. Additionally there are many helper utility functions and classes not directly related to graphics, such as memory management, file loading, etc.

	Additionally we have structured the engine such that a single interface is exposed to client applications while multiple "rendering backends" can be used. We have implemented a software rasterizer, software Raytracer and a proof of concept OpenGL backend using this interface. The OpenGL implementation is not designed to be feature complete, but is to show the interface can also be used as a wrapper around traditional rendering APIs, and we found it useful in our testing to ensure our own rendering achieved visually similar results.

* Code Structure

	This approach has lead our code base to be substantially larger than may have been expected for this coursework; an outline of the structure of the code is given below:

	- =source/xen= - Contains source code for the engine
		- =core= - Core utility functions and types not directly related to graphics, eg, memory managment
		- =math= - Implementation of mathematical helper functions and types. *Note that we do not rely on glm, but have implemented our own maths from scratch*
		- =graphics= - Definition of the shared graphics interface as well as various helper functions and types (eg, for dealing with colors or images) which do not rely on a particular rendering backend
		- =sren= - Stands for "software renderer". Contains implementation of both the software rasterizer and software Raytracer backends
		- =gl= - Contains a basic OpenGL implementation of the rendering backend
	- =examples= - Source code for various example applications. These are the "mains" and link against the shared xeno-engine libraries
	- =tests= - Source code for automated unit tests

	As well as the source code the repository also contains:
	- =tools= - Various helper scripts and utilities
	- =lib=   - Output directory for shared libraries generated by the build system
	- =bin=   - Output directory for executables generated by the build system. Also contains any resource files needed by these executables at runtime.

* Build System

	We have used CMake to manage the build process for this project.

	The entire engine and all examples may be built by:

	1. Creating a directory "build" in the root of the repository
	2. Running the command ~cmake ..~ from the build directory
	3. Running the command ~make~ in the build directory
	4. Running the example executables which will have been placed in bin

* External Libraries

	All external code is found in the =/extlibs= directory, the libraries and their uses are outlined below:

	- assimp
		- Used for loading mesh files
		- We convert the data into our own data structures on load for rendering
	- stb_image
		- Loading and reading image files into arrays of raw pixel values
	- thpool
		- Managing a pool of threads and work queue
		- Queue entries consist of a function pointer of the signature fn(void*), and a void pointer to some data
	- glew
		- Used for loading gl extensions
		- Used only in the OpenGL rendering backend

  Note that we do not depend on SDL or GLM, we have implemented our own versions of both the these libraries.

* Extensions

	Due to the way we have structured this coursework some extensions apply to all rendering backends, and others apply only to specific backends. Below we outline those that apply to each specifically, as well as those extensions which are shared between all rendering backends.

	:TODO: ensure all of these extensions have a reference to which demo application shows them off

** Shared

	 These are extensions which have been implemented for both the software raytracer and rasterizer.

	 - Per Vertex Attributes
		 - Colors and normals are specified per vertex rather than per triangle
		 - These values are interpolated across the surface of a triangle using perspective correct interpolation
		 - see =triangle-test= for a demo of per vertex colors
		 - :TODO: demo for per vertex normals (sphere rendering?)
	 - Arbitrary viewpoints
		 - Rendering can be performed in arbitrary viewpoints of a render target
		 - Try running the =cornell-box= demo with the device "Raytracer Camera Debug" to see a demonstration
	 - Arbitrary number of lights
		 - The engine supports multiple dynamic point lights per scene
		 - The only limit on number is desired performance and hardware capabilities (and having less than 2^32 so we can index them...)
	 - Per mesh emissive lighting
		 - Meshes can be assigned an emissive color
		 - This can be seen in the torus demo, where the 4 cubes embedded in the floor apear to glow regardless of the light's positions
		 - Additionally the small yellow cube in the cornell box demo is emissive
	 - Post Processing Pipeline
		 - The software rendering backends support applying "post-processing" steps after the image has been rendered
		 - We also have a demo application which loads an image, applies a (set of) post processor(s) and then saves the result, without creating a window etc
		 - :TODO: what post processors have we actually implemented?
		 - :TODO: write to depth buffer in raytracer to support fog
		 - :TODO: demoed by what?
	 - SIMD optimization transforming floating framebuffer to byte pixels for display
		 - Floating framebuffer pixels are used for better lighting calculations, but the transformation from floating in range 0-1 to bytes in range 0-255 was taking a lot of CPU time (97% in the starfield demo)
		 - We used SIMD compiler intrinsics to do all 4 color channels simultaneously
		 - Below are recorded FPS's in various configurations using the software rasterizer:
       | App         | Baseline | With SIMD | With 4 Threads and SIMD |
       |-------------+----------+-----------+-------------------------|
       | Starfield   |      250 |       275 | 330                     |
       | Cornell Box |      235 |       260 | 285                     |

** Raytracer

	 - Various optimizations to achieve real-time performance in 400x400 window
	   - Pre-generating a "scene"
			 - Sorting by whether shadow casting
			 - Segregating triangles from other primitive types
			 - Together these avoid some branches per ray in the rendering code, which speeds up rendering since branch's are expensive if they cause branch misprediction
		 - Threaded rendering
			 - The view region is broken up into multiple blocks such that the work can be divided amongst multiple threads
		 - :TODO: simd?

** Rasterizer

	 - Multiple primitive types
		 - Rasterizer can render lines and points as well as just triangles
		 - We support: TRIANGLES, LINES, LINE_STRIP, POINTS (as defined by the OpenGL standard - but we have implemented them in software)
		 - Note that the raytracer backend will fall back to using the rasterizer for all primative types except TRIANGLES since it doesn't make sense to ray trace points or lines which are infinitely thin
	 - Full clipping pipeline
		 - All primitive types are clipped by the engine such that the camera can be moved without segfaults, all geometry not in view is not drawn
		 - Geometry partially on and partially off of the screen is clipped to the viewport

** Meta Extensions

	 - Mesh System and Loading
		 - Flexible mesh system which can represent meshes with an arbitary number of attributes (eg position data, normal data, color data, etc) potentially each having a different type
		 - Use of assimp library to load mesh files (such as obj)
		 - Additional "load flags" can be specified to manipulate the mesh as it loads, eg generating normals, centering the local origin to be at (0,0,0), etc
	 - Windowing System
		 - Low level implementation of window management, event polling etc using raw operating system calls with no reliance on external libraries
		 - Implementation for both X11 and windows
		 - :TODO: add SDL implementation and benchmark
	 - Own math library
		 - We do not rely on GLM but instead have written all of our own maths from scratch
	 - OpenGL Backend
		 - ???
