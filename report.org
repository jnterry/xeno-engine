* Introduction

	We have implemented all that was requested for the 50% for both the raytracer and rasterizer. The rest of this document explains how we have expanded on this initial task.

	We have implemented this coursework as if it were the beginings of a full graphics engine (which we have named "Xeno Engine"). That is, the rendering portion is implemented as a (set of) shared libraries which applications link against. Additionally there are many helper utility functions and classes not directly related to graphics, such as memory management, file loading, etc.

	Additionally we have structured the engine such that a single interface is exposed to client applications while multiple "rendering backends" can be used. We have implemented a software rasterizer, software Raytracer and a proof of concept OpenGL backend using this interface. The OpenGL implementation is not designed to be feature complete, but is to show the interface can also be used as a wrapper around traditional rendering APIs, and we found it useful in our testing to ensure our own rendering achieved visually similar results.

* Code Structure

	This approach has lead our code base to be substantially larger than may have been expected for this coursework; an outline of the structure of the code is given below:

	- =source/xen= - Contains source code for the engine
		- =core= - Core utility functions and types not directly related to graphics, eg, memory managment
		- =math= - Implementation of mathematical helper functions and types. *Note that we do not rely on glm, but have implemented our own maths from scratch*
		- =graphics= - Definition of the shared graphics interface as well as various helper functions and types (eg, for dealing with colors or images) which do not rely on a particular rendering backend
		- =sren= - Stands for "software renderer". Contains implementation of both the software rasterizer and software Raytracer backends
		- =gl= - Contains a basic OpenGL implementation of the rendering backend
	- =examples= - Source code for various example applications. These are the "mains" and link against the shared xeno-engine libraries
	- =tests= - Source code for automated unit tests

	As well as the source code the repository also contains:
	- =tools= - Various helper scripts and utilities
	- =lib=   - Output directory for shared libraries generated by the build system
	- =bin=   - Output directory for executables generated by the build system. Also contains any resource files needed by these executables at runtime.

* Build System

	We have used CMake to manage the build process for this project.

	The entire engine and all examples may be built by:

	1. Creating a directory "build" in the root of the repository
	2. Running the command ~cmake ..~ from the build directory
	3. Running the command ~make~ in the build directory
	4. Running the example executables which will have been placed in bin

* Extensions

	Due to the way we have structured this coursework some extensions apply to all rendering backends, and others apply only to specific backends. Below we outline those that apply to each specifically, as well as those extensions which are shared between all rendering backends.

	:TODO: ensure all of these extensions have a reference to which demo application shows them off

** Shared

	 These are extensions which have been implemented for both the software raytracer and rasterizer.

	 - Per Vertex Attributes
		 - Colors and normals are specified per vertex rather than per triangle
		 - These values are interpolated across the surface of a triangle using perspective correct interpolation
		 - see =triangle-test= for a demo of per vertex colors
		 - :TODO: demo for per vertex normals (sphere rendering?)
	 - Arbitrary viewpoints
		 - :TODO: demonstrate by fixing the camera debug view
		 - Rendering can be performed in arbitrary viewpoints of a render target
	 - Post Processing Pipeline
		 - The software rendering backends support applying "post-processing" steps after the image has been rendered
		 - :TODO: what post processors have we actually implemented?
		 - :TODO: write to depth buffer in raytracer to support fog
		 - :TODO: demoed by what?

** Raytracer

	 - Optimizations
	   - Pre-generating a "scene"
			 - Sorting by whether shadow casting
			 - Segregating triangles from other primitive types
		 - :TODO: simd?

** Rasterizer

	 - Multiple primitive types
		 - Rasterizer can render lines and points as well as just triangles
		 - We support: TRIANGLES, LINES, LINE_STRIP, POINTS (as defined by the OpenGL standard - but we have implemented them in software)
		 - Note that the raytracer backend will fall back to using the rasterizer for all primative types except TRIANGLES since it doesn't make sense to ray trace points or lines which are infinitely thin
			 - :TODO: if we defined thickness for these primitives it actually would make sense to ray trace them...
	 - Full clipping pipeline
		 - All primitive types are clipped by the engine such that the camera can be moved without segfaults, all geometry not in view is not drawn
		 - Geometry partially on and partially off of the screen is clipped to the viewport

** Meta Extensions

	 - Mesh System and Loading
		 - Flexible mesh system which can represent meshes with an arbitary number of attributes (eg position data, normal data, color data, etc) potentially each having a different type
		 - Use of assimp library to load mesh files (such as obj)
	 - Windowing System
		 - Low level implementation of window management, event polling etc using raw operating system calls with no reliance on external libraries
		 - Implementation for both X11 and windows
		 - SIMD optimization for transforming floating framebuffer to byte pixels to display
		 - :TODO: add SDL implementation and benchmark
	 - Own math library

	 - OpenGL Backend
		 - ???
